\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xfrac}
\usepackage[all]{xy}
\usepackage{graphicx}
%\usepackage{fullpage}
\usepackage{hyperref}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}
\usepackage{listings}
\usepackage{MnSymbol}

%\setlength{\parindent}{0in}

\newcounter{counter1}

\theoremstyle{plain}
\newtheorem{myteo}[counter1]{Teorema}
\newtheorem{mylem}[counter1]{Lemma}
\newtheorem{mypro}[counter1]{Proposizione}
\newtheorem{mycor}[counter1]{Corollario}
\newtheorem*{myteo*}{Teorema}
\newtheorem*{mylem*}{Lemma}
\newtheorem*{mypro*}{Proposizione}
\newtheorem*{mycor*}{Corollario}

\theoremstyle{definition}
\newtheorem{mydef}[counter1]{Definizione}
\newtheorem{myes}[counter1]{Esempio}
\newtheorem{myex}[counter1]{Esercizio}
\newtheorem*{mydef*}{Definizione}
\newtheorem*{myes*}{Esempio}
\newtheorem*{myex*}{Esercizio}

\theoremstyle{remark}
\newtheorem{mynot}[counter1]{Nota}
\newtheorem{myoss}[counter1]{Osservazione}
\newtheorem*{mynot*}{Nota}
\newtheorem*{myoss*}{Osservazione}


\newcommand{\obar}[1]{\overline{#1}}
\newcommand{\ubar}[1]{\underline{#1}}

\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\pa}[1]{\left(#1\right)}
\newcommand{\ang}[1]{\left<#1\right>}
\newcommand{\bra}[1]{\left[#1\right]}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\left\|#1\right\|}

\newcommand{\pfrac}[2]{\pa{\frac{#1}{#2}}}
\newcommand{\bfrac}[2]{\bra{\frac{#1}{#2}}}
\newcommand{\psfrac}[2]{\pa{\sfrac{#1}{#2}}}
\newcommand{\bsfrac}[2]{\bra{\sfrac{#1}{#2}}}

\newcommand{\der}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pder}[2]{\pfrac{\partial #1}{\partial #2}}
\newcommand{\sder}[2]{\sfrac{\partial #1}{\partial #2}}
\newcommand{\psder}[2]{\psfrac{\partial #1}{\partial #2}}

\newcommand{\intl}{\int \limits}

\DeclareMathOperator{\de}{d}
\DeclareMathOperator{\id}{Id}
\DeclareMathOperator{\len}{len}

\DeclareMathOperator{\gl}{GL}
\DeclareMathOperator{\aff}{Aff}
\DeclareMathOperator{\isom}{Isom}

\DeclareMathOperator{\im}{Im}




\title{Relazione laboratorio 3 (quello di matematica)}
\author{Enrico Polesel}
\date{\today}

\begin{document}
\maketitle

\lstset{language=Matlab,frame=single}

\section{Problema diretto}

Il problema diretto viene risolto con la funzione
\begin{lstlisting}
function [Lambda,Y] = directSLP(q,L,N)
\end{lstlisting}
dove vogliamo risolvere il problema diretto con potenziale $q$
sull'intervallo $[-L,L]$ discretizzando su una griglia di $N+1$
punti. La funzione ritorna il vettore degli autovalori $\Lambda$ e
matrice $Y$ tale che la colonna $i$-esima rappresenta l'autofunzione
corrispondente all'autovettore $i$-esimo calcolata nei punti griglia. 

Il primo passo è riscalare il potenziale dall'intervallo $[-L,L]$
all'intervallo $[0,2\pi ]$ e poi calcolarlo su una griglia di $N+1$
punti equispaziati sull'intervallo.
\begin{lstlisting}
  v = @(xi) (L/pi)^2 * feval(q,(L/pi)*(xi - pi )) ;
  V = feval(v, linspace (0, 2*pi, N+1) ) ;
\end{lstlisting}

L'ultimo ingrediente che ci manca per poter risolvere il problema è la
matrice $D^{(2)}$ che, dati i valori di una funzione $y$ nei punti
griglia, ne resistuisce i valori di $y^{(2)}$ nei punti
griglia. Questa matrice viene calcolata nella funzione
\begin{lstlisting}
  function D = directSLP_inner2(N)
\end{lstlisting}
usando le formule (11) e (12) dell'articolo.

A questo punto va scritta (e risolta) la matrice che discretizza il
problema continuo agl'autovalori. Questo viene delegato\footnote{la
  scelta di dividere questo codice deriva dal fatto che viene
  riutilizzato nella funzione per risolvere il problema inverso} alla
funzione
\begin{lstlisting}
  function [ E, Y] = directSLP_inner1(D,V)
\end{lstlisting}
che, data la matrice di differnziazione $D$ (che nell'articolo viene
chiamata $D^{(2)}$) e il potenziale calcolato nei punti $V$, ritorna
gli autovalori $E$ (non riscalati a $[-L,L]$) e il valore del potenziale nei
punti griglia $Y$ (non riscalati $[-L,L]$).

La funzione \lstinline{directSLP_inner1}, dopo aver escluso i valori
ai bordi $0,2\pi$ perché usiamo condizioni al contorno di Dirichlet,
costruisce la matrice $M$ e ne calcola autovalori e autovettori
utilizzando la funzione \lstinline{eig} di MATLAB.

Le ultime operazioni che rimangonoda fare su \lstinline{directSLP}
sono di riscalare autovalori.


\section{Problema inverso}

Per risolvere il probelma inverso aggiungiamo l'ipotesi che il
potenziale, definito su $[-L,L]$ deve essere simmetrico rispetto a
$0$. 

Prendiamo in ingresso $M$ autovalori e ci proponiamo di risolvere il
problema trovando il valore del potenziale su una griglia di $N +1 =
2M+2$ punti esclusi i punti estremi (per motivi che saranno chiariti
in seguito).

Di nuovo rimappiamo il problema su $[0,2\pi]$, fissiamo la griglia
$\xi _0, \xi _1, ..., \xi _N$ con $\xi _i = \frac{2\pi}{N}i$ e
chiamiamo $v(\xi)$ il potenziale rimappato.

Riscrivendo il problema diretto
\begin{equation*}
  D^{(2)} \begin{pmatrix}
    y_0 \\
    y_1 \\
    \vdots \\
    y_M \\
    y_{M+1} \\
    \vdots \\
    y _{2M} \\
    y _{2M+1} 
  \end{pmatrix} 
 + \begin{pmatrix}
    v(\xi _0) \\
    & v(\xi _1) \\
    & & \ddots  \\
    & & & v(\xi _M) \\
    & & & & v(\xi _{M+1}) \\
    & & & & & \ddots \\
    & & & & & & v( \xi _ {2M} ) \\
    & & & & & & & v(\xi _{2M+1}) 
    \end{pmatrix}
    \begin{pmatrix}
    y_0 \\
    y_1 \\
    \vdots \\
    y_M \\
    y_{M+1} \\
    \vdots \\
    y _{2M} \\
    y _{2M+1} 
  \end{pmatrix}
  = \lambda y
\end{equation*}
osseviamo che, essendo $y_0 = y_{2M+1} = 0$ perché abbiamo fissato
condizioni al contorno di Dirichlet, nella relazione non compaiono i
valori di $v(\xi _0)$ e $v(\xi _{2M+1})$. Per simmetria abbiamo $v(\xi
_i) = v(\xi _{2M+1-i})$, quindi il vettore incognito del nostro
probelma è
\[
v = 
\begin{pmatrix}
  v_1 \\
  \vdots \\
  v_M 
\end{pmatrix}
=
\begin{pmatrix}
  v(\xi _1) \\
  \vdots \\
  v(\xi _M )
\end{pmatrix}
\]

Per passare da questo vettore ridotto al vettore ``completo'' si può
usare la matrice \lstinline{extender} così definita
\begin{lstlisting}
  extender = [ 
               zeros(1,M) ; 
               eye(M) ;
               flipud(eye(M)) ;
               zeros(1,M)
             ];
\end{lstlisting}
\begin{equation*}
  extender =
  \begin{pmatrix}
    0 & & 0 \\
    1 & & 0 \\
    & \ddots & \\
    0 & & 1 \\
    0 & & 1 \\
    & \udots & \\
    1 & &0 \\
    0 & & 0\\
  \end{pmatrix}
\end{equation*}

Vediamo ora come è stato implementata la funzione per risolvere il
probelma inverso

La funzione per calcolare il problema inverso è:
\begin{lstlisting}
  function q=inverseSLP(L,Lambda,Kmax,tol,v0)
\end{lstlisting}
dove \lstinline{L} è il limite dell'intervallo, \lstinline{Lambda} è
il vettore dei primi $M$ autovalori (ordinati in ordine decrescente),
\lstinline{Kmax} è il massimo numero di iterazioni da eseguire,
\lstinline{tol} è la tolleranza entro la quale si considera che la
soluzione ha raggiunto un punto fisso. \lstinline{v0} è un parametro
opzionale e rappresenta il potenziale iniziale da cui partire.

\subsection{Implementazione: preliminari}

Dopo aver incluso le librerie (\lstinline{regu} e
\lstinline{dmsuite}), la funzione setta (se non è stato passato come
argomento) il potenziale iniziale a $0$, riscala il problema da
$[-L,L]$ trasformando gli autovalori e si calcola i punti griglia.

Vengono precalcolate le seguenti matrici:
\begin{itemize}
\item La matrice di differenziazione $D^{(2)}$ che viene salvata in
  \lstinline{D}
\item La matrice \lstinline{extender} che estende il potenziale per
  simmetria
\item La matrice di penalizzazione \lstinline{PenMat}
\end{itemize}

Le prime due matrici sono semplici da costruire, per la prima basta
usare la funzione \lstinline{directSLP_inner2} e per la seconda la
  costruzione è già stata illustrata precedentemente.

Per la terza si fa BOH ???? TODO TODO TODO ma TODO un casino.

Prima di entrare nel ciclo vengongo inizializzate le variabili fra cui
il vettore del potenziale candidato \lstinline{vk} e la variabile di
conteggio cicli.


\subsection{Implementazione: ciclo principale: calcolo di $T(v_k)$ e dello jacobiano nel punto}

Dopo aver esteso per simmetria il potenziale, viene risolto il
problema diretto (con \lstinline{directSLP_inner1}). A questo punto è
possibile calcolare $T(v_k)$ come differenza tra i primi $M$ autovalori
calcolati e gli autovalori in ingresso.

Per applicare il metodo di Newton server calcolare lo Jacobiano di $T$
nel punto $v_k$. La formula viene ricavata derivando l'equazione di
Sturm Liouville, dopo alcuni calcoli algebrici si arriva alla
relazione
\begin{equation*}
  y_i ^T \der{V}{v_j} y_i = y_i ^T \der{\lambda _i}{v_j} y_i
\end{equation*}
dove $y_i$ è l'$i$-esimo autovettore relativo all'$i$-esimo autovalore
$\lambda _i$, $v_j$ è il valore del potenziale nel punto $\xi_j$ e $V$
è la matrice che ha sulla diagonale il valore del potenziale calcolato
nei punti di griglia esteso per simmetria.

Da questo si ricava che, utilizzando l'ortonormalità dei $y_i$, si ha
\begin{equation*}
  \der{\lambda _i}{v_j} = 2 ((y_i)_j) ^2
\end{equation*}
dove il fattore moltiplicativo $2$ deriva dal fatto che $v_j$ compare
due volte nella matrice $V$ (per il discorso dell'estensione).

Questa formula è implementata in
\begin{lstlisting}
  Ak =  2*(((Yk(2:M+1,1:M))').^2)
\end{lstlisting}
dove dobbiamo ricordarci che, per le condizioni al contorno di
Dirichlet, dobbiamo ignorare i valori del potenziale in $0$

\subsection{Implementazione: ciclo principale: regolarizzazione e
  aggiornamento del potenziale}

Visto il cattivo condizionamento dello Jacobiano $A_k$ si utilizza il
metodo di Tikhonov per regolarizzare il problema 
\begin{equation*}
  \Delta v _k = A_k ^{-1} T(v_k)
\end{equation*}

Per questo passaggio si utilizzano i Regularization Tools di Per
Christian Hansen che si trovano alla pagina
\url{http://www.imm.dtu.dk/~pcha/Regutools/regutools.html} 

Per prima cosa si calcola la scomposizione in valori singolari
generalizzata dello jacobiano e della matrice di penalizzazione con
l'istruzione
\begin{lstlisting}
  [ WW, SigmaM, XX, VV] = cgsvd(Ak,DiffMat) ;
\end{lstlisting}

Ora si può cercare il parametro di ottimizzazione ottimale con
l'istruzione
\begin{lstlisting}
  reg_corner = l_curve(WW,SigmaM,Tk,'Tikh') ;
\end{lstlisting}
e poi ottenere la soluzione regolarizzata con
\begin{lstlisting}
  Deltavk = tikhonov(WW,SigmaM,XX,Tk,reg_corner) ;
\end{lstlisting}

Ora che è disponibile $\Delta v_k$ è possibile aggiornare il valore di
\lstinline{vk} per la prossima iterazione
\begin{lstlisting}
  vk = vk - Deltavk ;
\end{lstlisting}




\end{document}

