\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xfrac}
\usepackage[all]{xy}
\usepackage{graphicx}
%\usepackage{fullpage}
\usepackage{hyperref}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}
\usepackage{listings}
\usepackage{MnSymbol}

%\setlength{\parindent}{0in}

\newcounter{counter1}

\theoremstyle{plain}
\newtheorem{myteo}[counter1]{Teorema}
\newtheorem{mylem}[counter1]{Lemma}
\newtheorem{mypro}[counter1]{Proposizione}
\newtheorem{mycor}[counter1]{Corollario}
\newtheorem*{myteo*}{Teorema}
\newtheorem*{mylem*}{Lemma}
\newtheorem*{mypro*}{Proposizione}
\newtheorem*{mycor*}{Corollario}

\theoremstyle{definition}
\newtheorem{mydef}[counter1]{Definizione}
\newtheorem{myes}[counter1]{Esempio}
\newtheorem{myex}[counter1]{Esercizio}
\newtheorem*{mydef*}{Definizione}
\newtheorem*{myes*}{Esempio}
\newtheorem*{myex*}{Esercizio}

\theoremstyle{remark}
\newtheorem{mynot}[counter1]{Nota}
\newtheorem{myoss}[counter1]{Osservazione}
\newtheorem*{mynot*}{Nota}
\newtheorem*{myoss*}{Osservazione}


\newcommand{\obar}[1]{\overline{#1}}
\newcommand{\ubar}[1]{\underline{#1}}

\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\pa}[1]{\left(#1\right)}
\newcommand{\ang}[1]{\left<#1\right>}
\newcommand{\bra}[1]{\left[#1\right]}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\left\|#1\right\|}

\newcommand{\pfrac}[2]{\pa{\frac{#1}{#2}}}
\newcommand{\bfrac}[2]{\bra{\frac{#1}{#2}}}
\newcommand{\psfrac}[2]{\pa{\sfrac{#1}{#2}}}
\newcommand{\bsfrac}[2]{\bra{\sfrac{#1}{#2}}}

\newcommand{\der}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pder}[2]{\pfrac{\partial #1}{\partial #2}}
\newcommand{\sder}[2]{\sfrac{\partial #1}{\partial #2}}
\newcommand{\psder}[2]{\psfrac{\partial #1}{\partial #2}}

\newcommand{\intl}{\int \limits}

\DeclareMathOperator{\de}{d}
\DeclareMathOperator{\id}{Id}
\DeclareMathOperator{\len}{len}

\DeclareMathOperator{\gl}{GL}
\DeclareMathOperator{\aff}{Aff}
\DeclareMathOperator{\isom}{Isom}

\DeclareMathOperator{\im}{Im}




\title{Relazione laboratorio 3 (quello di matematica)}
\author{Enrico Polesel}
\date{\today}

\begin{document}
\maketitle

\lstset{language=Matlab,frame=single}

\section{Problema diretto}

Il problema diretto viene risolto con la funzione
\begin{lstlisting}
function [Lambda,Y] = directSLP(q,L,N)
\end{lstlisting}
dove vogliamo risolvere il problema diretto con potenziale $q$
sull'intervallo $[-L,L]$ discretizzando su una griglia di $N+1$
punti. La funzione ritorna il vettore degli autovalori $\Lambda$ e
matrice $Y$ tale che la colonna $i$-esima rappresenta l'autofunzione
corrispondente all'autovettore $i$-esimo calcolata nei punti griglia. 

Il primo passo è riscalare il potenziale dall'intervallo $[-L,L]$
all'intervallo $[0,2\pi ]$ e poi calcolarlo su una griglia di $N+1$
punti equispaziati sull'intervallo.
\begin{lstlisting}
v = @(xi) (L/pi)^2 * feval(q,(L/pi)*(xi - pi )) ;
V = feval(v, linspace (0, 2*pi, N+1) ) ;
\end{lstlisting}

L'ultimo ingrediente che ci manca per poter risolvere il problema è la
matrice $D^{(2)}$ che, dati i valori di una funzione $y$ nei punti
griglia, ne resistuisce i valori di $y^{(2)}$ nei punti
griglia. Questa matrice viene calcolata nella funzione
\begin{lstlisting}
  function D = directSLP_inner2(N)
\end{lstlisting}
usando le formule (11) e (12) dell'articolo.

A questo punto va scritta (e risolta) la matrice che discretizza il
problema continuo agl'autovalori. Questo viene delegato\footnote{la
  scelta di dividere questo codice deriva dal fatto che viene
  riutilizzato nella funzione per risolvere il problema inverso} alla
funzione
\begin{lstlisting}
  function [ E, Y] = directSLP_inner1(D,V)
\end{lstlisting}
che, data la matrice di differnziazione $D$ (che nell'articolo viene
chiamata $D^{(2)}$) e il potenziale calcolato nei punti $V$, ritorna
gli autovalori $E$ (non riscalati a $[-L,L]$) e il valore del potenziale nei
punti griglia $Y$ (non riscalati $[-L,L]$).

La funzione \lstinline{directSLP_inner1}, dopo aver escluso i valori
ai bordi $0,2\pi$ perché usiamo condizioni al contorno di Dirichlet,
costruisce la matrice $M$ e ne calcola autovalori e autovettori
utilizzando la funzione \lstinline{eig} di MATLAB.

Le ultime operazioni che rimangonoda fare su \lstinline{directSLP}
sono di riscalare autovalori.


\section{Problema inverso}

Per risolvere il probelma inverso aggiungiamo l'ipotesi che il
potenziale, definito su $[-L,L]$ deve essere simmetrico rispetto a
$0$. 

Prendiamo in ingresso $M$ autovalori e ci proponiamo di risolvere il
problema trovando il valore del potenziale su una griglia di $N +1 =
2M+2$ punti esclusi i punti estremi (per motivi che saranno chiariti
in seguito).

Di nuovo rimappiamo il problema su $[0,2\pi]$, fissiamo la griglia
$\xi _0, \xi _1, ..., \xi _N$ con $\xi _i = \frac{2\pi}{N}i$ e
chiamiamo $v(\xi)$ il potenziale rimappato.

Riscrivendo il problema diretto
\begin{equation*}
  D^{(2)} \begin{pmatrix}
    y_0 \\
    y_1 \\
    \vdots \\
    y_M \\
    y_{M+1} \\
    \vdots \\
    y _{2M} \\
    y _{2M+1} 
  \end{pmatrix} 
 + \begin{pmatrix}
    v(\xi _0) \\
    & v(\xi _1) \\
    & & \ddots  \\
    & & & v(\xi _M) \\
    & & & & v(\xi _{M+1}) \\
    & & & & & \ddots \\
    & & & & & & v( \xi _ {2M} ) \\
    & & & & & & & v(\xi _{2M+1}) 
    \end{pmatrix}
    \begin{pmatrix}
    y_0 \\
    y_1 \\
    \vdots \\
    y_M \\
    y_{M+1} \\
    \vdots \\
    y _{2M} \\
    y _{2M+1} 
  \end{pmatrix}
  = \lambda y
\end{equation*}
osseviamo che, essendo $y_0 = y_{2M+1} = 0$ perché abbiamo fissato
condizioni al contorno di Dirichlet, nella relazione non compaiono i
valori di $v(\xi _0)$ e $v(\xi _{2M+1})$. Per simmetria abbiamo $v(\xi
_i) = v(\xi _{2M+1-i})$, quindi il vettore incognito del nostro
probelma è
\[
v = 
\begin{pmatrix}
  v_1 \\
  \vdots \\
  v_M 
\end{pmatrix}
=
\begin{pmatrix}
  v(\xi _1) \\
  \vdots \\
  v(\xi _M )
\end{pmatrix}
\]

Per passare da questo vettore ridotto al vettore ``completo'' si può
usare la matrice \lstinline{extender} così definita
\begin{lstlisting}
  extender = [ 
               zeros(1,M) ; 
               eye(M) ;
               flipud(eye(M)) ;
               zeros(1,M)
             ];
\end{lstlisting}
\begin{equation*}
  extender =
  \begin{pmatrix}
    0 & & 0 \\
    1 & & 0 \\
    & \ddots & \\
    0 & & 1 \\
    0 & & 1 \\
    & \udots & \\
    1 & &0 \\
    0 & & 0\\
  \end{pmatrix}
\end{equation*}


\end{document}

